\documentclass[12pt, a4paper]{article}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{enumerate}
\usepackage{nopageno} % usuwa numery stron
\usepackage[margin=.5in]{geometry} % zmniejsza margines
\usepackage{fouriernc} % śmieszna czcionka
\usepackage{algpseudocode}

\newcommand{\MBBR}{\mathbb{R}}
\newcommand{\MBBZ}{\mathbb{Z}}
\newcommand{\MBBN}{\mathbb{N}}
\newcommand{\MBBC}{\mathbb{C}}
\newcommand{\MBBK}{\mathbb{K}}
\newcommand{\MBBQ}{\mathbb{Q}}
\newcommand{\MCALO}{\mathcal{O}}

\newcounter{zadanie}
\newcommand{\zadanie}{\addtocounter{zadanie}{1}\section*{Zadanie \arabic{zadanie}}}

\title{Egzamin 2015/16}
\author{Stanisław Bitner}
\date{\today}

\begin{document}
\maketitle
\zadanie{}

Do rozwiązania następujących podpunktów przyda nam się znajomość stopni wejścia
i wyjścia wszystkich wierzchołków. Można je wyliczyć w czasie liniowym.
Sortujemy przedziały wierzchołków kubełkowo po wartościach $l$. Przechodzimy
liniowo od lewej do prawej -- stopień wejścia wierzchołka $i$ jest równy
liczbie zaczętych i niezakończonych jeszcze przedziałów. Stopień wyjścia
wierzchołka $v$ to $r[v] - l[v] + 1$. Odejmujemy jeszcze $1$ od każdego
wierzchołka z pętlą ($l[v] \le v \le r[v]$).
Złożoność: $\MCALO(n)$.

\subsection*{(a)}
Sprawdzamy, czy istnieje dokładnie $1$ wierzchołek o stopniu wejścia równym $0$
i czy istnieje dokładnie $n-1$ krawędzi. Jeśli tak, to tworzymy listę
sąsiedztwa, odpalamy $dfs$ z wierzchołka o stopniu wejścia równym $0$ i jeśli
odwiedzimy wszystkie wierzchołki, to odpowiedzią jest \textit{TAK}.
W przeciwnym razie odpowiedzią jest \textit{NIE}. Warunki te są konieczne
i wystarczające z definicji drzewa (spójny graf o $n-1$ krawędziach).
Złożoność: $\MCALO(n)$.

\subsection*{(b)}
Scalamy przedziały, które na siebie nachodzą ($2$ sąsiednie po posortowaniu).
Dla każdego przedziału każdy wierzchołek łączymy krawędzią z jego lewym
sąsiadem (dla skrajnie lewego elementu przedziału nic nie robimy). Każdy
wierzchołek $v$ łączymy krawędzią z $l[v]$ (oczywiście $r[v]$ już jest
połączone z $l[v]$). Otrzymujemy w ten sposób nieskierowany graf o co najwyżej
$2n$ krawędziach. Odpalamy DFS z dowolnego wierzchołka i sprawdzamy, czy
wszystkie są odwiedzone. Działa, ponieważ każdy wierzchołek będzie połączony
z jego przedziałem, a także wszystkie elementy jednego przedziału będą ze sobą
połączone.
Złożoność: $\MCALO(n)$.

\subsection*{(c)}
Sprawdzamy, czy graf jest słabo spójny oraz, czy sumaryczna liczba stopni
wyjścia jest równa sumarycznej liczbie stopni wejścia. Jeśli tak jest, to graf
jest eulerowski, w przeciwnym razie nie jest. Wiemy, że warunki te są konieczne
i wystarczające z wykładu z matematyki dyskretnej.
Złożoność: $\MCALO(n)$.

\zadanie{}
\subsection*{(a)}
Robimy sortowanie przez wstawianie, ale jak wykonamy już $2$ zamiany, to więcej
nie porównujemy. Wykonamy co najwyżej $n + 1 = 2017$ porównań, co jest liczbą
minimalną, bo może być $0$ inwersji i wtedy trzeba sprawdzić, czy cały ciąg
jest rzeczywiście posortowany.

\subsection*{(b)}
Najmniejszy element nie może być dalej niż na $2017$-tej pozycji, gdyż inaczej
tworzyłby on więcej niż $2016$ inwersji. Optymalne będzie więc znalezienie
minimum spośród pierwszych $2017$ elementów, co daje nam $2016$ porównań.

\zadanie{}
Tworzymy drzewo sufiksowe dla słowa $x \cdot x \cdot \$ \cdot y \cdot \#$.
Następnie szukamy wierzchołka o głębokości co najmniej $|x|$, który jest przodkiem $\$$
oraz $\#$. Jeśli taki wierzchołek istnieje, to w $y$ znajduje się pewne
przesunięcie cykliczne $x$. Głębokość definiujemy jako sumaryczną wagę krawędzi
na ścieżce z korzenia do wierzchołka.

\end{document}
